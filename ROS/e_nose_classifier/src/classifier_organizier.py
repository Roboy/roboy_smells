from ROS.e_nose_classifier.src.e_nose_classification_publisher import eNoseClassificationPublisher
from ROS.e_nose_classifier.src.e_nose_classification_test import eNoseClassificationTestPublisher
from ROS.e_nose_classifier.src.e_nose_subscriber import eNoseSubscriber
from classification.lstm_model import SmelLSTM
from classification.knn import KNN
from classification.naive_bayes import GNB
from e_nose.measurements import DataType, StandardizationType
from e_nose.online_reader import OnlineReader
import time
import numpy as np
import rospy


class ClassifierOrganizer:
    """
    This class is responsible for the organization of receiving the pure data from the data gathering machine (dgm)
     via ROS. Then it is modeled to Measurment objects, similiar to the computation of the sampling files generated by
     the dgm.
     It computes the classification either by knn or by a lstm.
     It shares the predicted classification via ROS to OUI or to our demo view
     Has to be executed with on a computer connected to a keyboard as it is required to set the start and endpoints
     of a measurement manualy via a shortcut
    """

    def __init__(self):
        print('Initialiting ROS node...')
        rospy.init_node('classifier_organizer', anonymous=True)
        print('Initialiting Subcomponents...')
        self.pub = eNoseClassificationPublisher()
        self.pub_test = eNoseClassificationTestPublisher()
        self.sub = eNoseSubscriber()
        failing_channels = [22, 31]
        working_channels = np.ones(64, bool)
        working_channels[failing_channels] = False
        num_working_channels = np.count_nonzero(working_channels)
        print(num_working_channels)
        self.online = OnlineReader(5, standardization=StandardizationType.LAST_REFERENCE,
                                   override_working_channels=working_channels)
        self.from_sample = 0
        self.sub.onUpdate += self.got_new_sample
        self.online.invoke_callback += self.gathered_data
        self.use_neural_network = True
        self.datatype = DataType.FULL
        self.recording = False

        if self.use_neural_network:
            self.lstm1 = SmelLSTM(input_shape=(1, 50, num_working_channels), num_classes=6, hidden_dim_simple=6,
                                  stateful=False)
            self.lstm2 = SmelLSTM(input_shape=(1, 1, num_working_channels), num_classes=6, hidden_dim_simple=12,
                                  stateful=True)

            self.model_name = 'LSTMTrainable_b8effb2c_12_batch_size=64,data_preprocessing=full,dim_hidden=6,lr=0.031576,use_lstm=True_2020-03-09_15-44-15nhhqrc38'
            self.model_name_2 = 'LSTMTrainable_acc8d910_3_batch_size=128,data_preprocessing=full,dim_hidden=12,lr=0.07236,use_lstm=False_2020-03-09_16-00-30jtxol1uj'

            # self.classifier.summary()
            self.lstm1.load_weights(self.model_name, checkpoint=260, path='classification/models/lstm_stateless/')
            self.lstm2.load_weights(self.model_name_2, checkpoint=120, path='classification/models/lstm_stateful/')

            self.classifier = SmelLSTM(input_shape=(1, 1, num_working_channels), num_classes=6, hidden_dim_simple=12)

            self.model_name = 'LSTMTrainable_231f7674_15_batch_size=128,data_preprocessing=high_pass,dim_hidden=12,lr=0.050039,stateful=True,use_lstm=True_2020-03-06_21-24-4970osptsr'
            self.classifier.summary()
            self.classifier.load_weights(self.model_name, checkpoint=160,
                                         path='classification/models/models_new_train_data_offset/')

        else:
            self.classifier = KNN(num_working_channels, data_dir='data', data_type=self.datatype)
            self.classifier2 = GNB(data_dir='data', data_type=self.datatype)
        print('ros e_nose classification node started successfully')

    def startMeas(self):
        """
        triggers start and endpoint of an endpoint via keyboard interaction

        """
        try:
            while True:
                self.pub_test.send_classification('ref')
                self.pub.send_classification('ref')
                var = input("Please enter something: ")
                if var.lower() == 'q':
                    break
                if not self.recording:
                    print('restarting classification', var)
                    self.from_sample = self.online.current_length
                    self.online.set_trigger_in(9)
                    self.recording = True
                else:
                    self.recording = False
                    self.online.invoke_at = 99999999999
                    self.pub_test.send_classification('ref')
                    self.pub.send_classification('ref')

        except KeyboardInterrupt:
            print('Interrupted...')

    def gathered_data(self):
        """
        if enough datapoints are received to do a preditction
        send data to the specified models and send the result to the ROS nodes
        :return: nothing
        """
        print('gathered data')
        data = self.online.get_since_n_as_measurement(self.from_sample)
        # print(data.correct_channels)
        # print(data.get_data().shape)
        data_for_classifier = data.get_data_as(self.datatype)
        self.pub_meas.send_classification(data_for_classifier)

        if self.use_neural_network:
            prediction = self.lstm2.predict_live(data)
            self.pub_test.send_classification(prediction)
            self.pub.send_classification(prediction)
        else:
            if (data_for_classifier.shape[0] > 40):
                prediction = self.classifier.predict(data_for_classifier)
                prediction_gnb = self.classifier2.predict(data_for_classifier)
                print('prediction_knn: ', prediction)
                print('prediction_gnb: ', prediction_gnb)
                self.pub_test.send_classification(prediction_gnb)
                self.pub.send_classification(prediction_gnb)
            else:
                self.pub_test.send_classification('ref')
                self.pub.send_classification('ref')
        self.online.set_trigger_in(2)
        print('sequence length:', data_for_classifier.shape[0])

    def got_new_sample(self):
        """
        adds a sample to the onlinereader which is doing the same as the meas
        """
        self.online.add_sample(self.sub.sensor_values)


if __name__ == '__main__':
    co = ClassifierOrganizer()
    co.startMeas()
